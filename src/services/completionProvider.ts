import * as vscode from 'vscode';
import { AIService } from './aiService';
import { LanguageService } from './languageService';

export class CompletionProvider implements vscode.CompletionItemProvider {
    private readonly aiService: AIService;
    private readonly languageService: LanguageService;

    constructor(aiService: AIService, languageService: LanguageService) {
        this.aiService = aiService;
        this.languageService = languageService;
    }

    async provideCompletionItems(
        document: vscode.TextDocument,
        position: vscode.Position,
        token: vscode.CancellationToken,
        context: vscode.CompletionContext
    ): Promise<vscode.CompletionItem[]> {
        try {
            // Get the current line and prefix
            const linePrefix = document.lineAt(position).text.substr(0, position.character);
            
            // Don't suggest if we're in a comment or string
            if (this.isInCommentOrString(document, position)) {
                return [];
            }

            // Get surrounding code for context
            const surroundingCode = this.getSurroundingCode(document, position);
            
            // Analyze code context
            const analysis = await this.languageService.analyzeCode(surroundingCode);

            // Generate suggestions based on context
            const suggestions = await this.aiService.generateCompletions(linePrefix, analysis);
            
            return this.createCompletionItems(suggestions);
        } catch (error) {
            console.error('Error providing completions:', error);
            return [];
        }
    }

    private isInCommentOrString(document: vscode.TextDocument, position: vscode.Position): boolean {
        // Get the semantic tokens for the current line
        const text = document.lineAt(position.line).text;
        
        // Basic check for comments (can be enhanced based on language)
        if (text.trim().startsWith('//') || text.trim().startsWith('#') || text.trim().startsWith('/*')) {
            return true;
        }

        // Basic check for strings (can be enhanced)
        let inString = false;
        let stringChar = '';
        
        for (let i = 0; i < position.character; i++) {
            const char = text.charAt(i);
            if ((char === '"' || char === "'") && (i === 0 || text.charAt(i - 1) !== '\\')) {
                if (!inString) {
                    inString = true;
                    stringChar = char;
                } else if (stringChar === char) {
                    inString = false;
                }
            }
        }

        return inString;
    }

    private getSurroundingCode(document: vscode.TextDocument, position: vscode.Position): string {
        // Get a few lines before and after the current position for context
        const startLine = Math.max(0, position.line - 5);
        const endLine = Math.min(document.lineCount - 1, position.line + 5);
        
        let code = '';
        for (let i = startLine; i <= endLine; i++) {
            code += document.lineAt(i).text + '\n';
        }
        
        return code;
    }

    private createCompletionItems(suggestions: string[]): vscode.CompletionItem[] {
        return suggestions.map(suggestion => {
            const item = new vscode.CompletionItem(suggestion, vscode.CompletionItemKind.Snippet);
            
            // Add documentation if available
            item.documentation = new vscode.MarkdownString('Generated by NeuroForge AI');
            
            // Set a high priority for our suggestions
            item.sortText = '0' + suggestion;
            
            // Add command to track usage
            item.command = {
                command: 'neuroforge.trackCompletion',
                title: 'Track Completion Usage',
                arguments: [suggestion]
            };
            
            return item;
        });
    }
}